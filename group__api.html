<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Arachne: Arachne Public API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Arachne
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="group__api.html"><span>Arachne&#160;Public&#160;API</span></a></li>
      <li><a href="md_wiki_Main.html"><span>Design&#160;Wiki</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Arachne Public API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structArachne_1_1ThreadId.html">Arachne::ThreadId</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArachne_1_1SpinLock.html">Arachne::SpinLock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArachne_1_1ConditionVariable.html">Arachne::ConditionVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1e9c1e27d7487a7ba883dd1253d82db7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#ga1e9c1e27d7487a7ba883dd1253d82db7">Arachne::init</a> (int *argcp, const char **argv)</td></tr>
<tr class="separator:ga1e9c1e27d7487a7ba883dd1253d82db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf382f9c6509ffc8f1d3be42485311711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#gaf382f9c6509ffc8f1d3be42485311711">Arachne::shutDown</a> ()</td></tr>
<tr class="separator:gaf382f9c6509ffc8f1d3be42485311711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d1d6e02a5b1043b1a432bf176530f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#ga2d1d6e02a5b1043b1a432bf176530f03">Arachne::waitForTermination</a> ()</td></tr>
<tr class="separator:ga2d1d6e02a5b1043b1a432bf176530f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfca274f07beb43fa7aa7f308dc40577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#gadfca274f07beb43fa7aa7f308dc40577">Arachne::yield</a> ()</td></tr>
<tr class="separator:gadfca274f07beb43fa7aa7f308dc40577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad678d8be2d336471f2db46152596e59f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#gad678d8be2d336471f2db46152596e59f">Arachne::sleep</a> (uint64_t ns)</td></tr>
<tr class="separator:gad678d8be2d336471f2db46152596e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5341ffc9639e9171d52b9b1d95f7f573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#ga5341ffc9639e9171d52b9b1d95f7f573">Arachne::block</a> ()</td></tr>
<tr class="separator:ga5341ffc9639e9171d52b9b1d95f7f573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac378920f57c297f4f55a8654c8216855"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#gac378920f57c297f4f55a8654c8216855">Arachne::signal</a> (ThreadId id)</td></tr>
<tr class="separator:gac378920f57c297f4f55a8654c8216855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga368594db1c44bbaafb9f75de8775db29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#ga368594db1c44bbaafb9f75de8775db29">Arachne::join</a> (ThreadId id)</td></tr>
<tr class="separator:ga368594db1c44bbaafb9f75de8775db29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14398f8509bb3e823972e6ad8deda2d"><td class="memItemLeft" align="right" valign="top">ThreadId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#gac14398f8509bb3e823972e6ad8deda2d">Arachne::getThreadId</a> ()</td></tr>
<tr class="separator:gac14398f8509bb3e823972e6ad8deda2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5756fe8aa1c368a4c0d32c0601f6616"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#gad5756fe8aa1c368a4c0d32c0601f6616">Arachne::setErrorStream</a> (FILE *stream)</td></tr>
<tr class="separator:gad5756fe8aa1c368a4c0d32c0601f6616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f9d479b2b8098d401021d0994e16c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#ga8f9d479b2b8098d401021d0994e16c63">Arachne::testInit</a> ()</td></tr>
<tr class="separator:ga8f9d479b2b8098d401021d0994e16c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcbfc4a2842e4ea651010b69c8e551a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#gadcbfc4a2842e4ea651010b69c8e551a7">Arachne::testDestroy</a> ()</td></tr>
<tr class="separator:gadcbfc4a2842e4ea651010b69c8e551a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0049424587db2518820335a1d7c74a92"><td class="memTemplParams" colspan="2">template&lt;typename _Callable , typename... _Args&gt; </td></tr>
<tr class="memitem:ga0049424587db2518820335a1d7c74a92"><td class="memTemplItemLeft" align="right" valign="top">ThreadId&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__api.html#ga0049424587db2518820335a1d7c74a92">Arachne::createThread</a> (_Callable &amp;&amp;__f, _Args &amp;&amp;...__args)</td></tr>
<tr class="separator:ga0049424587db2518820335a1d7c74a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga166c3382a4fa9df8da4820473d1b938f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structArachne_1_1ThreadId.html">Arachne::ThreadId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api.html#ga166c3382a4fa9df8da4820473d1b938f">Arachne::NullThread</a></td></tr>
<tr class="separator:ga166c3382a4fa9df8da4820473d1b938f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Most of the functions in this API, with the exception of <a class="el" href="group__api.html#ga1e9c1e27d7487a7ba883dd1253d82db7">Arachne::init()</a>, <a class="el" href="group__api.html#gaf382f9c6509ffc8f1d3be42485311711">Arachne::shutDown()</a>, <a class="el" href="group__api.html#ga2d1d6e02a5b1043b1a432bf176530f03">Arachne::waitForTermination()</a>, and <a class="el" href="group__api.html#ga0049424587db2518820335a1d7c74a92">Arachne::createThread()</a>, should only be called from within Arachne threads.</p>
<p>In order to allow unit tests in non-Arachne threads to run, <a class="el" href="group__api.html#ga8f9d479b2b8098d401021d0994e16c63">Arachne::testInit()</a> should be called once before all unit tests run, and <a class="el" href="group__api.html#gadcbfc4a2842e4ea651010b69c8e551a7">Arachne::testDestroy()</a> should be called once after all unit tests finish. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5341ffc9639e9171d52b9b1d95f7f573"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Arachne::block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Block the current thread until another thread invokes <a class="el" href="group__api.html#ga368594db1c44bbaafb9f75de8775db29">join()</a> with the current thread's <a class="el" href="structArachne_1_1ThreadId.html">ThreadId</a>. </p>

</div>
</div>
<a class="anchor" id="ga0049424587db2518820335a1d7c74a92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Callable , typename... _Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ThreadId Arachne::createThread </td>
          <td>(</td>
          <td class="paramtype">_Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>__f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spawn a new thread with a function and arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__f</td><td>The main function for the new thread. </td></tr>
    <tr><td class="paramname">__args</td><td>The arguments for __f. The total size of the arguments cannot exceed 48 bytes, and arguments are taken by value, so any reference must be wrapped with std::ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is an identifier for the newly created thread. If there are insufficient resources for creating a new thread, then NullThread will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gac14398f8509bb3e823972e6ad8deda2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ThreadId Arachne::getThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a thread handle for the currently executing thread, identical to the one returned by the createThread call that initially created this thread.</p>
<p>When invoked from a non-Arachne thread, this function returns Arachne::NullThread. </p>

</div>
</div>
<a class="anchor" id="ga1e9c1e27d7487a7ba883dd1253d82db7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Arachne::init </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>argcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets up state needed by the thread library, and must be invoked before any other function in the thread library is invoked. It is undefined behavior to invoke other Arachne functions before this one.</p>
<p>Arachne will take configuration options from the command line specified by argc and argv, and then update the values of argv and argc to reflect the remaining arguments.</p>
<p>Here are the current available options. </p><pre class="fragment">--numCores
   The starting number of cores the application should use.
--maxNumCores
   The largest number of core the appliation may use
--stackSize
   The size of each user stack.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argcp</td><td>The pointer to argc, the number of arguments passed to the application. This pointer will be used to update argc after Arachne has consumed its arguments. </td></tr>
    <tr><td class="paramname">argv</td><td>The pointer to the command line argument array, which will be modiifed to remove the options that Arachne recognizes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga368594db1c44bbaafb9f75de8775db29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Arachne::join </td>
          <td>(</td>
          <td class="paramtype">ThreadId&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block the current thread until the thread identified by id finishes its execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the thread to join. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad5756fe8aa1c368a4c0d32c0601f6616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Arachne::setErrorStream </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the target of the error stream, allowing redirection to an application's log. </p>

</div>
</div>
<a class="anchor" id="gaf382f9c6509ffc8f1d3be42485311711"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Arachne::shutDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This call will cause all Arachne threads to terminate, and cause <a class="el" href="group__api.html#ga2d1d6e02a5b1043b1a432bf176530f03">waitForTermination()</a> to return.</p>
<p>It is typically used only for an application's unit tests, where the global teardown function in the unit test would call <a class="el" href="group__api.html#gaf382f9c6509ffc8f1d3be42485311711">Arachne::shutDown()</a> followed immediately by <a class="el" href="group__api.html#ga2d1d6e02a5b1043b1a432bf176530f03">Arachne::waitForTermination()</a>.</p>
<p>This function can be called from any Arachne or non-Arachne thread. </p>

</div>
</div>
<a class="anchor" id="gac378920f57c297f4f55a8654c8216855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Arachne::signal </td>
          <td>(</td>
          <td class="paramtype">ThreadId&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the thread referred to by <a class="el" href="structArachne_1_1ThreadId.html">ThreadId</a> runnable. If one thread exits and another is created between the check and the setting of the wakeup flag, this signal will result in a spurious wake-up. If this method is invoked on a currently running thread, it will have the effect of causing the thread to immediately unblock the next time it blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the thread to signal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad678d8be2d336471f2db46152596e59f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Arachne::sleep </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sleep for at least ns nanoseconds. The amount of additional delay may be impacted by other threads' activities such as blocking and yielding. </p>

</div>
</div>
<a class="anchor" id="gadcbfc4a2842e4ea651010b69c8e551a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Arachne::testDestroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be invoked in unit test teardown to clean up the state that makes Arachne functions callable from the unit test. </p>

</div>
</div>
<a class="anchor" id="ga8f9d479b2b8098d401021d0994e16c63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Arachne::testInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be invoked in unit test setup to make Arachne functions callable from the unit test, which is not an Arachne thread.</p>
<p>This function sets up just enough state to allow the current thread to execute unit tests which call Arachne functions. We assume that the unit tests are run from the main kernel thread which will never swap out when running the dispatch() loop. </p>

</div>
</div>
<a class="anchor" id="ga2d1d6e02a5b1043b1a432bf176530f03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Arachne::waitForTermination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called by the main application thread and will block until Arachne is terminated via a call to <a class="el" href="group__api.html#gaf382f9c6509ffc8f1d3be42485311711">shutDown()</a>.</p>
<p>Upon termination, this function tears down all state created by init, and restores the state of the system to the time before init is called. </p>

</div>
</div>
<a class="anchor" id="gadfca274f07beb43fa7aa7f308dc40577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Arachne::yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used as part of cooperative multithreading to give other Arachne threads on the same core a chance to run. It will return when all other threads have had a chance to run. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga166c3382a4fa9df8da4820473d1b938f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structArachne_1_1ThreadId.html">Arachne::ThreadId</a> Arachne::NullThread</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value represents the non-existence of a thread and can be returned by any Arachne function that would normally return a <a class="el" href="structArachne_1_1ThreadId.html">ThreadId</a>.</p>
<p>One example is createThread when there are not enough resources to create a new thread. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
