<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Arachne: Arachne Kernel API Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Arachne
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="group__api.html"><span>Arachne&#160;Public&#160;API</span></a></li>
      <li><a href="md_wiki_Main.html"><span>Design&#160;Wiki</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Arachne Kernel API Design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>System calls</h2>
<ol type="1">
<li><code>initArachne(yieldInfoSharedMemoryPtr)</code>: Called at Arachne startup to establish a shared memory pointer for communication with ther kernel about how many threads the application should continue to run (this shared memory pointer is <em>not</em> thread local).</li>
<li><code>blockUntilCoreAvailable(coreInfoSharedMemoryPtr)</code>: Adds the calling thread to the kernel's internal list of sleeping threads that it will wake up and run when a core becomes available. The shared memory pointer is used to tell the application which core this thread is running on (it should point to a thread local variable) after this call returns.</li>
<li><code>setNumCores(priorityArray[])</code>: Given an array of the number of cores to allocate at each priority, the kernel will asynchronously wake up the requested number of threads from their calls to <code>blockUntilCoreAvailable</code> and allow them to run on individual cores.</li>
</ol>
<h2>Kernel Scheduler</h2>
<p>The kernel will have a new high-priority scheduling class that only allows one thread on its run queue at a time. It keeps track of the threads that have called <code>blockUntilCoreAvailable</code> and chooses which threads to wake up and add to a run queue when the application calls <code>setNumCores</code>. The kernel communicates via the <code>coreInfoSharedMemoryPtr</code> (provided by <code>blockUntilCoreAvailable</code>) which core this thread is running on.</p>
<p>When the kernel needs to communicate to the application that it wants a core back, it will write the number of cores it wants <em>the application</em> to have to the <code>yieldInfoSharedMemoryPtr</code> (provided by <code>init</code>). It does not communicate how many cores it wants back because that would require the application to write to the shared memory and create a race.</p>
<h3>Blocking System Calls (Kernel Side)</h3>
<p>The kernel knows that there is a blocking system call when a run queue that previously had a thread running is empty. The kernel will wake up a sleeping thread and substitute it into the run queue, providing the thread's new core information via <code>coreInfoSharedMemoryPtr</code>.</p>
<p>When a blocking system call returns, the kernel will communicate to the substituted thread via <code>coreInfoSharedMemoryPtr</code> that it should yield at the next opportunity so that the original thread can run.</p>
<h2>Arachne Library (Userspace)</h2>
<p>The Arachne library creates n+k kernel threads (using <code>std::thread</code>), where n is the number of cores and k is some extra number of cores to have in reserve in case of blocking system calls. It adds more threads to the pool if it ever runs out. We are creating threads in userspace under the assumption that it is easier to deal with them there than in the kernel. Each thread will have the following main loop: </p><pre class="fragment">while (true):
    blockUntilCoreAvailable()
    if we are the first thread running on this core (check shared memory):
        initialize state
        run normally
    else:
        // There was a blocking system call on this core
        increment counter for the threads running on this core
        run until the kernel tells us via shared memory that we should yield
</pre><p>When the application notices via the <code>yieldInfoSharedMemoryPtr</code> that it needs to give back some number of cores, it will choose which cores to give up and then call <code>blockUntilCoreAvailable</code> on all threads running on that core.</p>
<h1>Open Questions</h1>
<ol type="1">
<li>How will priorities work?</li>
<li>What is the minimum set of functions we need to implement in the scheduler? </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
